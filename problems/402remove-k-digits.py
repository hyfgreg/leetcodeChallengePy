"""
402. 移掉 K 位数字
给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。


示例 1 ：

输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
示例 2 ：

输入：num = "10200", k = 1
输出："200"
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
示例 3 ：

输入：num = "10", k = 2
输出："0"
解释：从原数字移除所有的数字，剩余为空就是 0 。


提示：

1 <= k <= num.length <= 105
num 仅由若干位数字（0 - 9）组成
除了 0 本身之外，num 不含任何前导零
通过次数80,142提交次数244,960

tag: 栈 贪心 字符串 单调栈
背诵，第一次见，单调栈很薄弱啊~！
"""


class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        """
        让我们从一个简单的例子开始。给定一个数字序列，例如 425，如果要求我们只删除一个数字，那么从左到右，我们有 4、2 和 5 三个选择。我们
        将每一个数字和它的左邻居进行比较。从 2 开始，2 小于它的左邻居 4。假设我们保留数字 4，那么所有可能的组合都是以数字 4（即 42，45）
        开头的。相反，如果移掉 4，留下 2，我们得到的是以 2 开头的组合（即 25），这明显小于任何留下数字 4 的组合。因此我们应该移掉数字 4。
        如果不移掉数字 4，则之后无论移掉什么数字，都不会得到最小数。基于上述分析，我们可以得出「删除一个数字」的贪心策略：

        长度为n的数字学列[D0D1D2D3...Dn-1] 从左往右找到第一个位置i(i>0)，使得Di-1>Di，并且删除Di-1，如果不存在这样的数字，说明数字单调不降，删除最后一个数字
        """
        stack = []
        for n in num:
            while stack and k > 0 and stack[-1] > n:
                stack.pop()
                k -= 1
            stack.append(n)
        if k > 0:
            stack = stack[:-k]
        ret = ''.join(stack).lstrip('0')

        return ret if ret else '0'


if __name__ == '__main__':
    s = Solution()
    num = "10200"
    k = 1
    print(s.removeKdigits(num, k))
